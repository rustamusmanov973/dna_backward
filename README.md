# dna_backward

Документация по скрипту «backbone.py».

Скрипт создан на основе программы "backward.py" (Wassenaar et al.). Данная программа прилагается в каталоге dna_backward/ .
1. Параметры запуска

	Программа получает на ввод файл в формате .pdb и выдает файл в формате .gro .

-f  input_file.pdb -o output_file.gro

2. Область применения программы

	Пусть на вход подан файл в формате .pdb, содержащий координаты coarse-grain (крупно-зернистых) гранул (бидов, beads) произвольной молекулы ДНК в силовом поле SIRAH[1].
	Программа восстанавливает полноатомную модель данной модели ДНК и записывает полученные координаты в файл с расширением .gro. 

3. Объяснение ключевых участков кода программы.

	В начале программы вводятся вспомогательные математические функции (norm2, norm, normalize, iprod (inner product), mvmul (matrix-vector multiplication), det (determinant), m_inv (inverted matrix), vr (round vector), vadd (add vectors), svmul (vector-number multiplication), crossprod (crossproduct).
	
	Затем вводится функция pdbAtom. Она осуществляет «парсинг» входного .pdf файла.

	В связи с некоторыми особенностями силовых полей удобно создать новый файл «inter.pdb» и копировать в него подаваемый на вход файл с заменой DYX на DY, где Y = A, T, G, C. Это делается с помощью объекта predet. 
	
	Затем созается объект «struc» класса «Structure» на основе файла «inter.pdb».
У этого объекта есть несколько переменных:
self.atoms, список из кортежей, в кажном из которых приведена информация парсинга .pdb файла (напр. ('  PX', 'DT  ', 2, 'I', 0.436, -0.63, 89.218), название бида PX, название остатка DT, номер остатка 2, имя цепи I  и координаты).
Self.residues, группировка self.atoms в списки по остаткам
self.sequence, последовательность остатков, получающаяся из входного .pdb файла.
Self.backbone, список списков (цепей) словарей (по одному словарю на остаток). В каждом словаре приведены уже восстановленные координаты атомов сахарофосфатного остова (например [{'O1P': (0.436, -0.63, 89.218),  ……}]  )
Получается в определении класса Structure присутствует процедура восстановления координат атомов из координат coarse-grained гранул. Это делается с помощью функции inter(a, b, x, y), которая берет на вход координаты двух гранул (a, b) и отношение, в котором будущая частица будет делить отрезок ab (x, y). C помощью этой функции восстанавливаются координаты всех атомов сахарофосфатного остова ДНК, используя координаты трех гранул (PX, C1Y, C5Y; Y = A,T,G,C) на остаток.
	Затем следует определение класса «Option» и собственно опций, из которых основные - «-f» и «-o» для обозначения входного и выходного файлов.
Для лучшего понимания дальнейшего скрипта рекомендуется обратиться к файлу __init__.py в папке Mapping, подключенному к backbone.py как модуль.

	Сразу появляется ряд функций mirror_DY(x,y,z,residue) (Y — nucleotide), берут на ввод координаты атома (x, y, z)  и название остатка, к которому он пренадлежит. 
	Для того, чтобы объяснить роль этой функции обратимся к основной идее программы. 
В папке Mapping есть 4 .map файла. Они служат инструкцией для восстановления атомов азотистого основания по заданным координатам соответствующих гранул ( их всего 4 на основание). Ниже приведен разбор файла .map:

[molecule]
DA

Обозначается имя остатка — Аденин

[ sirah ]
PX C5X C1A C2A N1A N6A
Имеется в виду, что в силовом поле sirah для этого остатка определено 6 гранул. Перечислены их названия.

[ atoms ]
   1     P          PX
...
   5     O5'        C5X PX
…
   19     N7        C1A C1A ….   С1A  N6A… N6A -C2A -C2A ….. 
В разделе [atoms] определено соответствие между атом и corse-grained гранулами. Если гранула одна, то координата атома должна совпадать с координатой гранулы. Если их много, то координата атома должна совпадать с центром масс приведенных гранул. Для каждого остатка имеется гранула, которая может идти со знаком (-) и при том, только одна для каждого остатка. Если перед гранулой стоит минус, значит в будущем ее нужно будет отразить зеркально относительно линии, проходящей через две другие гранулы в определении атома .map файла. Именно эта операция проводится функцией «mirror_DY» (Y — nucleotide). Она берет координаты гранулы (например C2A) и остатка (например DA) и выдает координаты уже отраженной частицы. 
	Далее идет функция _average(mas, residue). Mas — это список из списков вида [-1 или 1, ('  PX', 'DA  ', 291, 'J', -2.857, -19.019, 85.599)] для каждого остатка. -1 добавляется с целью отметить, что данная гранула должна входить с отрицательным знаком, то есть ее нужно будет зеркально отражать. Residue — есть имя остатка, например DA.  Функция _average: сначала нам необходимо создать список «a» вида [(' C1A', 'DA  ', 291, 'J', -0.178, -15.44, 88.248), …..]. Для этого мы извлекаем первый элемент списка mas, в случае, если mas[0] == 1. В противном случае нам необходимо применить функцию mirror к координатам в первом элементе mas и уже затем добавить в список. Теперь, получив список «a» применяем функцию нахождения центра масс системы частиц для набора a и получаем координаты восстановленного атома. Стоит отметить, что эту операцию нужно проводить только тогда, когда атом уже не восстановлен ранее, в классе «Structure», что и написано в коде got = coords.get(want , _average(mas, residue)), где want это координаты уже восстановленных атомов.  Полученные координаты записываем в массив «got». Далее, возвращаясь к программе «bacbone.py» пишем полученные координаты атомов в координатный файл .gro 


























[1] http://www.sirahff.com/
